# 敌人系统分析与扩展总结

## 项目敌人系统架构分析

### 1. 核心继承层次结构

```
obj_character_parent (所有角色的基础)
    ├── 管理移动、重力、碰撞
    ├── 处理生命值系统
    ├── 无敌帧机制
    └── 精灵翻转逻辑
    
    └── obj_enemy_parent (所有敌人的基类)
            ├── 设置伤害值和移动速度
            ├── 自动巡逻系统
            └── 转向逻辑（遇墙/悬崖）
            
            └── obj_enemy1 (具体敌人实例)
                    └── 自定义属性
```

### 2. 敌人系统关键机制

#### a) 移动系统
- **速度设置**: `move_speed` 变量控制移动速度
- **初始方向**: 随机选择左或右开始移动
- **无摩擦**: `friction_power = 0` 确保敌人持续移动

#### b) 巡逻逻辑
在 `obj_enemy_parent` 的 End Step 事件中：
- 检测前方墙壁（4倍速度距离）
- 检测前方悬崖（64像素下方）
- 遇到障碍自动反转 `vel_x`

#### c) 战斗系统
玩家与敌人的碰撞处理：
- **从上方踩踏**: 敌人 HP 归零，玩家反弹
- **侧面碰撞**: 玩家受伤，产生击退效果
- **伤害值**: 由敌人的 `damage` 属性决定

#### d) 败北机制
- 当 HP <= 0 时，替换为 `defeated_object`
- 播放败北动画后自动销毁

### 3. 已实现的新敌人: Enemy2

#### 创建的文件
```
objects/obj_enemy2/
    ├── Create_0.gml          # 初始化代码
    └── obj_enemy2.yy         # 对象配置

objects/obj_enemy2_defeated/
    ├── Other_7.gml           # 动画结束事件
    └── obj_enemy2_defeated.yy # 对象配置
```

#### Enemy2 的特殊属性
```gml
move_speed = 4;      // 2倍于 enemy1 的速度
max_hp = 2;          // 需要踩踏两次
hp = 2;
damage = 2;          // 对玩家造成 2 点伤害
```

#### 与 Enemy1 的对比
| 属性 | Enemy1 | Enemy2 |
|------|--------|--------|
| 移动速度 | 2 | 4 |
| 生命值 | 1 | 2 |
| 伤害 | 1 | 2 |
| 难度 | 低 | 中 |

## 如何使用新敌人

### 在 GameMaker 中使用
1. 打开房间编辑器
2. 在对象列表中找到 `obj_enemy2`
3. 拖放到关卡中的任意位置
4. 运行游戏测试

### 注意事项
- 当前使用 enemy1 的精灵作为占位符
- 建议后续创建专属精灵: `spr_enemy2_walk` 和 `spr_enemy2_defeated`
- Enemy2 需要两次踩踏才能击败，注意难度平衡

## 扩展更多敌人类型的建议

### 方案1: 跳跃型敌人
```gml
// 在 Step 事件中添加
if (alarm[0] <= 0 && grounded) {
    vel_y = -jump_speed;
    alarm[0] = 120; // 2秒后再次跳跃
}
```

### 方案2: 飞行敌人
```gml
// 在 Create 事件中
grav_speed = 0; // 禁用重力
friction_power = 0;

// 添加垂直移动
vel_y_pattern = 2; // 上下浮动
```

### 方案3: 追踪玩家的敌人
```gml
// 在 Step 事件中
if (instance_exists(obj_player)) {
    var dir = sign(obj_player.x - x);
    vel_x = dir * move_speed;
}
```

### 方案4: 射击敌人
```gml
// 在 Step 事件中添加定时射击
if (alarm[1] <= 0) {
    instance_create_layer(x, y, layer, obj_enemy_bullet);
    alarm[1] = 180; // 3秒一次
}
```

## 敌人系统的设计优势

1. **良好的继承结构**: 
   - 新敌人只需继承 `obj_enemy_parent`
   - 自动获得移动、碰撞、转向等基础功能

2. **高度可定制**:
   - 通过简单修改变量即可创建不同类型
   - 可以轻松扩展新的行为

3. **统一的接口**:
   - 所有敌人都响应相同的碰撞逻辑
   - 玩家交互保持一致

4. **模块化设计**:
   - 敌人本体和败北动画分离
   - 便于独立调整和复用

## 关键代码文件索引

### 基础系统
- `objects/obj_character_parent/Create_0.gml` - 角色基础属性
- `objects/obj_character_parent/Step_0.gml` - 碰撞检测
- `objects/obj_character_parent/Step_1.gml` - 重力和摩擦
- `objects/obj_character_parent/Step_2.gml` - 精灵翻转和生命值

### 敌人系统
- `objects/obj_enemy_parent/Create_0.gml` - 敌人基础属性
- `objects/obj_enemy_parent/Step_2.gml` - 巡逻和转向逻辑

### 玩家交互
- `objects/obj_player/Collision_obj_enemy_parent.gml` - 玩家与敌人碰撞

### 碰撞检测
- `scripts/scr_collisions/scr_collisions.gml` - 碰撞检测函数

## 总结

这个项目的敌人系统采用了清晰的面向对象设计，通过继承机制实现了代码复用。新增敌人类型只需：

1. 创建继承自 `obj_enemy_parent` 的新对象
2. 在 Create 事件中设置自定义属性
3. 可选：添加额外的事件处理特殊行为
4. 创建对应的 defeated 对象

这种设计使得敌人系统易于扩展和维护，是 GameMaker 项目中值得学习的良好实践。
